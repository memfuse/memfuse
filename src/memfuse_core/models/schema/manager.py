"""Schema manager for database operations."""

from typing import List, Dict, Any
from .m0_raw import M0RawSchema
from .m1_episodic import M1EpisodicSchema


class SchemaManager:
    """Manager for database schema operations."""
    
    def __init__(self):
        self.schemas = {
            "m0_raw": M0RawSchema(),
            "m1_episodic": M1EpisodicSchema()
        }
    
    def get_schema(self, table_name: str):
        """Get schema for a specific table."""
        return self.schemas.get(table_name)
    
    def get_all_schemas(self) -> Dict[str, Any]:
        """Get all schemas."""
        return self.schemas
    
    def generate_init_sql(self) -> str:
        """Generate complete initialization SQL for all tables."""
        sql_parts = []
        
        # Header
        sql_parts.append("-- MemFuse Database Schema")
        sql_parts.append("-- Generated by SchemaManager")
        sql_parts.append("-- This file contains the complete database schema for M0 and M1 tables")
        sql_parts.append("")
        
        # Extensions
        sql_parts.append("-- =============================================================================")
        sql_parts.append("-- SECTION 1: Extensions and Configuration")
        sql_parts.append("-- =============================================================================")
        sql_parts.append("")
        sql_parts.append("-- Enable required extensions")
        sql_parts.append("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";")
        sql_parts.append("CREATE EXTENSION IF NOT EXISTS \"vector\";")
        sql_parts.append("CREATE EXTENSION IF NOT EXISTS \"timescaledb\";")
        sql_parts.append("")
        
        # Trigger functions first
        sql_parts.append("-- =============================================================================")
        sql_parts.append("-- SECTION 2: Trigger Functions")
        sql_parts.append("-- =============================================================================")
        sql_parts.append("")
        
        for schema_name, schema in self.schemas.items():
            if hasattr(schema, 'get_trigger_functions_sql'):
                functions = schema.get_trigger_functions_sql()
                if functions:
                    sql_parts.append(f"-- Trigger functions for {schema_name}")
                    sql_parts.extend(functions)
                    sql_parts.append("")
        
        # Tables and their components
        for schema_name, schema in self.schemas.items():
            sql_parts.append("-- =============================================================================")
            sql_parts.append(f"-- SECTION: {schema_name.upper()} TABLE")
            sql_parts.append("-- =============================================================================")
            sql_parts.append("")
            
            # Table creation
            sql_parts.append(f"-- {schema_name} table definition")
            sql_parts.append(schema.generate_create_table_sql())
            sql_parts.append("")
            
            # Indexes
            indexes = schema.generate_indexes_sql()
            if indexes:
                sql_parts.append(f"-- Indexes for {schema_name}")
                sql_parts.extend(indexes)
                sql_parts.append("")
            
            # Triggers
            triggers = schema.generate_triggers_sql()
            if triggers:
                sql_parts.append(f"-- Triggers for {schema_name}")
                sql_parts.extend(triggers)
                sql_parts.append("")
        
        # Utility functions
        sql_parts.append("-- =============================================================================")
        sql_parts.append("-- SECTION: Utility Functions")
        sql_parts.append("-- =============================================================================")
        sql_parts.append("")
        
        # Similarity normalization function
        sql_parts.append("""-- Function to normalize cosine similarity to 0-1 range
CREATE OR REPLACE FUNCTION normalize_cosine_similarity(distance FLOAT)
RETURNS FLOAT AS $$
BEGIN
    -- pgvector cosine distance is 1 - cosine_similarity
    -- Convert to similarity: 1 - distance
    -- Clamp to [0, 1] range
    RETURN GREATEST(0.0, LEAST(1.0, 1.0 - distance));
END;
$$ LANGUAGE plpgsql IMMUTABLE;""")
        sql_parts.append("")
        
        # Vector search function
        sql_parts.append("""-- Function for vector similarity search
CREATE OR REPLACE FUNCTION vector_similarity_search(
    query_embedding vector(384),
    similarity_threshold FLOAT DEFAULT 0.7,
    max_results INTEGER DEFAULT 10
)
RETURNS TABLE(
    chunk_id UUID,
    content TEXT,
    similarity_score FLOAT,
    conversation_id UUID,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.chunk_id,
        c.content,
        normalize_cosine_similarity(c.embedding <=> query_embedding) as similarity_score,
        c.conversation_id,
        c.created_at
    FROM m1_episodic c
    WHERE normalize_cosine_similarity(c.embedding <=> query_embedding) >= similarity_threshold
    ORDER BY c.embedding <=> query_embedding ASC
    LIMIT max_results;
END;
$$ LANGUAGE plpgsql;""")
        sql_parts.append("")
        
        # Statistics function
        sql_parts.append("""-- Function to get memory layer statistics
CREATE OR REPLACE FUNCTION get_memory_stats()
RETURNS TABLE(
    layer VARCHAR(20),
    record_count BIGINT,
    table_size TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        'M0 Messages'::VARCHAR(20) as layer,
        COUNT(*) as record_count,
        pg_size_pretty(pg_total_relation_size('m0_raw')) as table_size
    FROM m0_raw
    UNION ALL
    SELECT 
        'M1 Chunks'::VARCHAR(20) as layer,
        COUNT(*) as record_count,
        pg_size_pretty(pg_total_relation_size('m1_episodic')) as table_size
    FROM m1_episodic
    UNION ALL
    SELECT 
        'M1 Embeddings'::VARCHAR(20) as layer,
        COUNT(*) as record_count,
        'N/A'::TEXT as table_size
    FROM m1_episodic 
    WHERE embedding IS NOT NULL;
END;
$$ LANGUAGE plpgsql;""")
        sql_parts.append("")
        
        # Completion message
        sql_parts.append("-- Schema initialization completed")
        sql_parts.append("SELECT 'MemFuse database schema initialized successfully' as status;")
        
        return "\n".join(sql_parts)
    
    def get_table_names(self) -> List[str]:
        """Get list of all table names."""
        return list(self.schemas.keys())
    
    def validate_schema(self, table_name: str) -> bool:
        """Validate schema definition for a table."""
        schema = self.get_schema(table_name)
        if not schema:
            return False
        
        # Basic validation
        if not schema.table_name:
            return False
        
        if not schema.columns:
            return False
        
        # Check for primary key
        has_primary_key = any(col.primary_key for col in schema.columns)
        if not has_primary_key:
            return False
        
        return True
    
    def get_column_info(self, table_name: str) -> List[Dict[str, Any]]:
        """Get column information for a table."""
        schema = self.get_schema(table_name)
        if not schema:
            return []
        
        return [
            {
                "name": col.name,
                "data_type": col.data_type,
                "nullable": col.nullable,
                "default": col.default,
                "primary_key": col.primary_key,
                "unique": col.unique,
                "comment": col.comment
            }
            for col in schema.columns
        ]
